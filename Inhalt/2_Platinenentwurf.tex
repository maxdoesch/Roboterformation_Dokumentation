% !TEX root = ../Projektdokumentation.tex
\chapter{Platinenentwurf}\label{ch:platinenentwurf}
Ein Ziel dieser Projektarbeit war die Entwicklung einer Platform, welche alle notwendigen Komponenten kompakt zusammenfasst.
Hierfür müssen elektronische Bauteile und mechanische wie Motoren oder 3D-Druckteile gut aufeinander abgestimmt werden.
Während auf der einen Seite die Funktionalität des Gesamtsystems wichtig ist, soll andererseits jeder Roboter auch visuell durch ein Array von RGB-Leds auffallen.
Mithilfe eines doppel Platinenstack wurde erreicht, dass die Motoren direkt auf die untere Platine (Main\_PCB) aufgeschraubt werden können und 
die Leds auf der oberen Platine (Led\_PCB) den richtigen Abstand zum Led-Diffusor haben. 


\section{Blockschaltbild}
\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{figures/Platinenentwurf/PCB_Blockdiagramm.png}
    \caption{Blockdiagramm PCB}
\end{figure}
Das Blockdiagramm zeigt den Leistungs- und Signalfluss zwischen den Bauteilen auf beiden Platinen.
Die primäre Stromversorgung übernehmen drei 18650 LiIon Zellen. Diese haben im geladenen Zustand eine Gesamtspannung von $3*4.2 = 12.6V$ 
und können über einen Schalter an- und ausgeschalten werde. Der Roboter ist gegenüber Verpolung aller Zellen geschützt.
Für die Versorgung des Mikrocontrollers müssen die 12V mit einem Buck-Converter auf 3.3V gewandelt werden.
Außerdem soll der Roboter für den Test-/Programmierbetrieb auch über die 5V der USB-C oder der JTAG/Programmierschnittstelle stationär betrieben werden können.
Hierfür müssen die Spannungen elektronisch getrennt werden, um einen Kurzschluss zwischen den Potentialen zu verhindern.
Der ESP32 kann über die USB-C Schnittstelle und eine separate serielle Schnittstelle programmiert werden.
Für den 2 Quadranten betrieb der Motoren ist eine doppel H-Brücke vorgesehen. 
Die Ist-Geschwindigkeit wird über Hallsensoren auf den Bürstenmotoren ermittelt.
Auf die zweite Platine wird der Marvelmind Mini-RX Empfänger aufgesteckt. Dieser kommuniziert über UART mit dem Mikrocontroller. 
Die beiden externen Mikrofone können einfach auf die LED\_PCB Platine gelötet werden. 
Da das Marvelmind Modul 5V benötigt werden diese über einen zweiten Buck-Converter erzeugt.
Die 43 RGB Led-ICs werden über die 12V Spannung versorgt und mittels einer Datenleitung vom Mikrocontroller angesteuert.
Da die Led Bausteine 5V Logikpegel benötigen, wird das 3.3V Signal vom ESP32 mittels 1-Bit Level Shifter verstärkt.



\section{Bauteile}
\subsection{ESP32}
Das Herzstück des Roboters bildet ein ESP32-WROVER-E in der 8MB Flash Variante. 
Dieses SOM (System On Module) von Espressife beinhaltet einen Xtensa LX6 Dualcore Mikrocontroller mit 520kB internen
und 8MB externen SRAM, sowie 2MB internen und 8MB externen Flash Speicher. 
Die externen Speicher sind über SPI verbunden und werden über eine MMU (Memory Management Unit) in den Speicherbereich gemappt.
Des Weiteren bietet der ESP32 verschiedene Peripherie wie Timer, GPIO, UART, I2C, PWM und Wifi.
Espressife stellt mit dem ESP-IDF Framework unter anderem ein Hardwareabstraktions Layer bereit über welches Peripherie leicht initialisiert und gesteuert werden kann.
Aus diesem Grund bleibt es dem Programmierer erspart sich mit der Hardware auf Registerebene zu beschäftigen.
Dies macht den ESP32 zu einem beliebten IOT-Mikrocontroller im Hobbybereich.
Diagramm \ref{fig:esp32pinlayout} und Tabelle \ref{tab:esp32pinbelegung} beschreibt die Pinbelegung am ESP32.

\begin{figure}[H]
    \centering
    \begin{minipage}{0.35\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/ESP32_Pin_Layout.png}
        \caption{ESP32 Pin Layout}
        \label{fig:esp32pinlayout}
    \end{minipage}
    \hfill
    \begin{minipage}{0.55\textwidth}
        \centering
        \resizebox*{\textwidth}{!}{
        \begin{tabular}{|l|l|l|}
            \hline
            Name       & Pin Nr. & Funktion                                                 \\ \hline
            GND        & 1       & Ground                                                   \\ \hline
            3V3        & 2       & Power                                                    \\ \hline
            EN         & 3       & Enable Signal                                            \\ \hline
            Sensor\_VP & 4       & Hall Sensor 1 Motor B                                    \\ \hline
            Sensor\_VN & 5       & Hall Sensor 2 Motor B                                    \\ \hline
            IO34       & 6       & Hall Sensor 1 Motor A                                    \\ \hline
            IO34       & 7       & Hall Sensor 2 Motor A                                    \\ \hline
            IO32       & 8       & SCL I2C Bus                                              \\ \hline
            IO33       & 9       & SDA I2C Bus                                              \\ \hline
            IO25       & 10      & serielles LED Signal                                     \\ \hline
            IO26       & 11      & Marvelmind UART TX                                       \\ \hline
            IO27       & 12      & Marvelmind UART RX                                       \\ \hline
            IO14       & 13      & JTAG\_TMS                                                \\ \hline
            IO12       & 14      & JTAG\_TDI                                                \\ \hline
            GND        & 15      & Ground                                                   \\ \hline
            IO13       & 16      & JTAG\_TCK                                                \\ \hline
            IO15       & 23      & JTAG\_TDO                                                \\ \hline
            IO2        & 24      & GPIO2 (sollte nicht verwendet werden, da Strapping Pin)  \\ \hline
            IO0        & 25      & GPIO0 Boot Mode Selektor                                 \\ \hline
            IO4        & 26      & NC                                                       \\ \hline
            IO5        & 29      & GPIO5 (sollte nicht verwendet werden, da Strapping Pin)  \\ \hline
            IO18       & 30      & DRV8841 Motor B IN2                                      \\ \hline
            IO19       & 31      & DRV8841 Motor B IN1                                      \\ \hline
            IO21       & 33      & DRV8841 Motor A IN1                                      \\ \hline
            RXD0       & 34      & UART für Programmierung RX                               \\ \hline
            TXD0       & 35      & UART für Programmierung TX                               \\ \hline
            IO22       & 36      & DRV8841 Motor A IN2                                      \\ \hline
            IO23       & 37      & DRV8841 Enable                                           \\ \hline
            GND        & 38      & Ground                                                   \\ \hline
        \end{tabular}  
        }   
    \caption{ESP32 Pin Belegung}
    \label{tab:esp32pinbelegung}        
    \end{minipage}
\end{figure}

\subsubsection*{Power-Up}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/Platinenentwurf/ESP32 Power-Up.png}
    \caption{ESP32 Power-Up}
    \label{fig:esp32powerup}
\end{figure}
Wie die Illustation \ref{fig:esp32powerup} zeigt muss der Enable Pin (im Datenblatt CHIP\_PU genannt) für eine bestimmte Zeit $t_0 = 50\mu s$ nach dem Power-Up auf Low gehalten werden.
Das gleiche gilt für den Reset des Mikrocontrollers $t_1 = 50\mu s$. Die Power-Up/Reset Schaltung könnte zum Beispiel als Parallelschaltung eines RC Tiefpasses mit einem Taster umgesetzt werden.

\subsubsection*{Boot-Mode}
Der ESP32 verfügt über zwei verschiedene Boot Modis. Beim SPI Boot wird die Firmware aus dem Flash in den Arbeitsspeicher geladen.
Der Download Boot dient zum flashen einer neuen Firmware. Für den Wechsel zwischen den Modis wertet der Mikrocontroller beim Power-Up die Strapping Pins GPIO0 und GPIO2 aus.
\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    Pin   & Default   & SPI Boot   & Download Boot \\ \hline
    GPIO0 & Pull-Up   & 1          & 0             \\ \hline
    GPIO2 & Pull-Down & Don't care & 0             \\ \hline
    \end{tabular}
    \caption{ESP32 Boot Mode}
    \label{tab:esp32bootmode}
\end{table}
Da GPIO2 intern auf LOW gezogen wird, muss dieser Pin nicht verbunden werden. Die Boot Modus Wahl geschieht dann alleine über GPIO0.

\subsubsection*{UART0}
Über die Pins UART0-RX/TX wird eine serielle Verbindung erstellt. 
Diese ermöglicht das Schreiben in den Flash-Speicher im Dowload-Boot und einen seriellen Monitor für z.B. printf Debugging im SPI-Boot.

\subsubsection*{JTAG}
TMS, TDI, TCK, TDO können für JTAG-Debugging verwendet werden.

\subsubsection*{I2C}
Auf beiden Platinen sind Anschlüsse an den I2C-Bus des ESP32 vorgesehen. Über diesen soll aber primär eine 9DOF-IMU (Intertial Measurement Unit) betrieben werden.

\subsection{CP2102N}
\label{sub:cp2102n}
Der CP2102N wirkt als "Übersetzer" zwischen der USB2.0 Fullspeed Schnittstelle und dem UART Interface.
Somit kann durch einen Virtual COM Port Treiber am Host-PC über USB- auf die UART-Schnittstelle zugegriffen werden.
Die UART Seite wird über die Pins RXD/TXD und das differenzielle USB Signal über die D+/D- Pins mit dem CP2102N verbunden.
Dies ermöglicht das Programmieren des ESP32 einfach über USB. Außerdem kann auch auf den seriellen Monitor zugegriffen werden.
Des Weiteren kann das RTS (Ready to Send; LOW aktiv) und DTR (Data Terminal Ready; LOW aktiv) Signal zur Auswahl des Boot Modus und Neustarten des Mikrocontrollers verwendet werden.
Die folgende Tabelle \ref{tab:cp2102n_dtr_rts} zeigt die notwendige logische Verknüfung der Signale.

\begin{table}[H]
    \centering
    \begin{tabular}{ll|ll}
    DTR & RTS & EN & GPIO0 \\ \hline
    1   & 1   & 1  & 1     \\
    0   & 0   & 1  & 1     \\
    1   & 0   & 0  & 1     \\
    0   & 1   & 1  & 0    
    \end{tabular}
    \caption{ESP32 DTR RTS}
    \label{tab:cp2102n_dtr_rts}
\end{table}

\subsection{Pololu 20D 63:1 Getriebemotoren}
\begin{figure}[H]
    \centering
    \begin{minipage}{0.40\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/Pololu_20D_Motor.jpg}
        \caption{Pololu 20D Motor}
        \label{fig:pololu_motor}
    \end{minipage}
    \hfill
    \begin{minipage}{0.40\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/Pololu_20D_Rueckplatte.jpg}
        \caption{Pololu 20D Rückplatte}
        \label{fig:pololu_rueckplatte}      
    \end{minipage}
\end{figure}
Die Pololu 20D Getriebemotoren sind für 12V Spannung ausgelegt. Dabei haben sie einen Leerlaufstrom von $80mA$ und im Stillstand $1.6A$.
Die Leerlaufdrehzahl wird durch das eingebaute Getriebe um den Faktor 63 auf $220RPM$ reduziert.
Für Drehzahlmessungen kann der Motor durch eine Platine und eine Magnetscheibe mit 10 Polen an der Motorwelle erweitert werden.
Auf der Platine befinden sich jeweils zwei Hall-Magnetfeldsensoren. Diese geben je nach Magnetfeldrichtung einen HIGH oder LOW Spannungspegel aus.
Durch Zählen der Pegeländerungen pro Zeiteinheit kann die Geschwindigkeit des Motors berechnet werden.
Die Drehrichtung wird über das Vorzeichen der Phasendifferenz der Signale von den beiden Hallsensoren ermittelt.

\subsection{DRV8841}
\begin{figure}[H]
    \centering
    \begin{minipage}{0.4\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/DRV8841_Pinout.png}
        \caption{DRV8841 Pinout}
        \label{fig:drv8841pinout}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \resizebox*{\textwidth}{!}{
            \begin{tabular}{|l|l|l|l|}
                \hline
                xIN1 & xIN2 & xOUT1 & xOUT2 \\ \hline
                0    & 0    & L     & L     \\ \hline
                0    & 1    & L     & H     \\ \hline
                1    & 0    & H     & L     \\ \hline
                1    & 1    & H     & H     \\ \hline
            \end{tabular}
        }   
    \caption{DRV8841 H-Brücken Logik}
    \label{tab:drv8841_hbridgelogic}        
    \end{minipage}
\end{figure}
Mit der doppel H-Brücke DRV8841 von Texas Instruments können zwei DC-Motoren im 2 Quadranten-Betrieb betrieben werden.
Die beiden Motorausgänge (AOUT/BOUT) dürfen jeweils mit bis zu 2.5A belastet werden. 
Die Pololu 20D Motoren haben einen Stillstandsstrom von maximal 1.6A. 
Somit sollte der Treiber auch ohne die interne Strombegrenzung sicher betrieben werden können.
Dies bedeutet die Pins AI0, AI1, BI0, BI1 müssen nicht verbunden werden, ISENA und ISENB können direkt mit GND verbunden werden
und AVREF, BVREF werden auf 3.3V gezogen.
Geschwindigkeit und Drehrichtung der Motoren wird über die Pegel und Pulseweite der (AIN1/AIN2; BIN1/BIN2) 
Eingangssignale gesteuert. \ref{tab:drv8841_hbridgelogic}
Um den Motortreiber zu aktivieren müssen nRESET und nSLEEP auf 3.3V gezogen werden.
Des Weiteren ist auch noch ein Bootstrap-Kondensator zwischen den Pins CP1/CP2 als Ladepumpe notwendig.

\subsection{Marvelmind Mini-RX}
\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/Marvelmind MiniRX Molex.png}
        \caption{Marvelmind Molex Pinout}
        \label{fig:marvelmind_molexpinout}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/Marvelmind MiniRX mic.png}
        \caption{Marvelmind Mic Pinout}
        \label{fig:marvelmind_micpinout}      
    \end{minipage}
\end{figure}
Der Marvelmind Mini-Rx Beacon empfängt die Ultraschallsignale der HW4.9 Beacons für die Berechnung der Pose des Roboters.
Über die integrierte UART Schnittstelle kann dann die Pose an den Mikrocontroller gesendet werden.
Da durch das Modul effektiv eine dritte Platine entsteht, wurde darauf geachtet diese möglichst platzschonend in den Platinenstack zu integrieren.
Hierfür wird das Gehäuse und der eingebaute Akku entfernt. Die Stromversorgung wird über auf der LED Platine erzeugte 5V gewährleistet.
Die 5V Spannung sowie die seriellen Signale RX/TX sind über die interne Molex PicoBlade Steckverbindung \ref{fig:marvelmind_molexpinout} mit dem Modul verbunden.
Da die UART Schnittstelle mit 3.3V Logikpegeln arbeitet kann diese ohne Probleme direkt mit dem ESP32 verbunden werden.
Des Weiteren soll das eingebaute Mikrofon durch zwei externe ersetzt werden. Diese sind über das 2.0mm 2x4 Pinout mit dem Mini-RX verbunden \ref{fig:marvelmind_micpinout}.

\subsection{WS2815B}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/Platinenentwurf/WS2815B_Pinout.png}
    \caption{WS2815B Pinout}
    \label{fig:ws2815B_pinout}
\end{figure}
Der WS2815B ist eine RGB-Led mit eingebautem LED-Treiber. Dieser Baustein kann über die Pins DO, DIN in Reihe zu einem Led-Array verschalten werden. 
Der RGB Farbwert wird in einem 24Bit (8Bit grün, 8 Bit rot, 8 Bit blau) Feld codiert. Dieser Wert wird für alle LEDs in einem Datenstrom kaskadiert und an den Eingang DIN der erste LED gesendet.
Diese schneidet sich den ersten Farbwert ab und gibt den restlichen Datenstrom über DO an die nächste LED weiter. Somit sind alle Bausteine einzeln adressierbar.
Des Weiteren wird 0 und 1 nicht über den Wert der Spannungspegel codiert. Um ein Bit zu übertragen benötigt es zu Beginn eine positive Flanke, dann eine negative und zum Schluss wieder ein positive Flanke.
Der Wert wird dann in die Dauer der High und Low-Phasen codiert.
Die LED wird mit 12V gespeist. Die Logikpegel der Datensignale arbeiten allerdings mit 5V Spannung. An den VCC Pin kann ein Entkopplungskondensator angeschlossen werden.
Außerdem wird der Eingang BIN mit DO der vorletzten LED verbunden und bringt somit Redundanz beim Aufall eines Treibers.

\subsection{PI4ULS5V201}
Da die LED-Treiber 5V Signalpegel benötigen, können diese nicht direkt mit dem ESP32 angesteuert werden.
Der PI4ULS5V201 ist ein Level-Shifter IC und kann somit den 3.3V Pegel des ESP32 auf die benötigten 5V verstärken. 

\subsection{TPS54331}
\label{sub:tps54331}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/Platinenentwurf/TPS54331.png}
    \caption{TPS54331 Pinout}
    \label{fig:tps54331_pinout}
\end{figure}
Auf den beiden Platinen gibt es insgesamt drei Spannungen (12V, 5V, 3.3V). 
Mit dem Buck Converter TPS54331 werden jeweils 5V und 3.3V aus den 12V erzeugt.
Da mit 5V und 3.3V keine Leistung gespeist wird, ist der Baustein mit maximal 3A Dauerstrom ausreichend dimensioniert.
Abbildung \ref{fig:tps54331_pinout} zeigt eine typische Verschaltung des Buck Converters.
Die Ausgangsspannung kann über die beiden Widerstände $R_{D1}$ und $R_{D2}$ eingestellt werden.
Das Datenblatt liefert eine Tabelle für die Dimensionierung aller passiven Bauelemente je nach Eingangs- und Ausgangsspannung.
Die beiden Widerstände $R_{en1}$ und $R_{en2}$ am EN Eingang dienen zur Einstellung des erlaubten Spannungsbereiches für VIN und werden mit folgender Formel berechnet:
$$R_{en1} = \frac{V_{start} - V_{stop}}{3\mu A}$$
$$R_{en2} = \frac{1.25V}{\frac{V_{start} - 1.25V}{R_{en1}} + 1\mu A}$$

\section{Schaltplan}
Die Schaltpläne für dieses Projekt wurden mit KiCad erstellt. KiCad ist ein freies ECAD Programm unter der GNU GPL Lizenz. 
Es integriert unter anderem Tools wie einen Schaltplan Editor "Eeschema" und einen Layout Editor "PCBNew".
Die beiden Schaltpläne MainPCB und LedPCB für dieses Projekt liegen als KiCad und PDF Dateien bei.
Die Bauteile wurden nach den Vorgaben und Applikationsbeispielen in den Datenblättern verschaltet.
Aus diesem Grund wird im Folgenden nur auf Besonderheiten eingegangen.

\subsection*{Hauptschalter und Verpolungsschutz}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/Platinenentwurf/KiCad_Powerswitch.png}
    \caption{KiCad Hauptschalter und Verpolungsschutz}
    \label{fig:kicad_hauptschalter_verpolungsschutz}
\end{figure}
Dieser Teil ermöglicht das Anschalten über einen mechanischen Schalter. 
Außerdem wird die Platine vor Verpolung der LiIon Zellen und Überstrom/Kurzschluss geschützt.
Der IRF7404 ist ein PMOS Transistor mit niedrigem Drain-Source Widerstand.
Befindet sich der Schalter SW1 in der dargestellten Stellung ist $V_{GS} = 0V$ und der Mosfet sperrt.
In der zweiten Schalterstellung wird $V_{GS} = 0V - V_{+BATT} \approx -12V$ und der Mosfet wird leitend.
Q2 wirkt als Verpolungsschutz für die gesamte Schaltung. Bei richtiger Polung von $V_{+BATT}$ ist die Body-Diode leitend und
$V_{GS} \approx -12V$. Bei Verpolung hat das Transistor Gate das Potential 12V. $V_{GS} < 0V$ ist somit unmöglich und der Mosfet sperrt.
Die Sicherung F1 schützt den Rest der Schaltung vor Überlast und Kurzschluss.

\subsection*{Eingangsquellenschutz}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/Platinenentwurf/KiCad_Eingansquellen_Schutz.png}
    \caption{KiCad Eingangsquellenschutz}
    \label{fig:kicad_eingangsquellenschutz}
\end{figure}
Die obere Schaltung befindet sich am Eingang des 3.3V Spannungswandlers.
Da dieser den Mikrocontroller versorgt, muss der Buck Converter über die LiIon Akkus (12V), USB (5V) und JTAG-/Programmierinterface (5V) betrieben werden können.
Es reicht nicht aus die verschiedenen Spannungschienen direkt zu verbinden, 
da sonst die Gefahr eines Kurzschlusses zwischen den Potentialen besteht, wenn mehrere Spannungsquellen gleichzeitig aktiv sind.
VBUS und 5VD werden durch Dioden vor Potentialausgleich geschützt. Diese Spannungen werden nur zum Debuggen verwendet. 
Es fließt nur wenig Strom und der Spannungsabfall über den Dioden ist somit hinnehmbar. 
Da die 12V den Roboter im Normalbetrieb mit teilweise großer Stromaufnahme versorgen, darf es keinen großen Spannungsabfall über der schützenden Komponente geben.
Der PMOS Transistor AO3401 hat einen geringen Drain-Source Widerstand und somit wenig Leistungsverlust bei großem Strom.
Sind 12V verbunden schaltet Q3 immer durch da $V_{GS} < 0V$. Falls nur VBUS oder 5VD aktiv ist, wird $V_{GS} = 0V$. Die 12V Schiene bleibt somit Spannungsfrei.

\subsection*{Reset- und Bootmodeschaltung}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/Platinenentwurf/KiCad_Boot_Reset.png}
    \caption{KiCad Reset- und Bootmodeschaltung}
    \label{fig:kicad_resetboot}
\end{figure}
In \ref{sub:cp2102n} wurde gezeigt, dass es möglich ist den ESP32 über das DTR und RTS Signal neuzustarten und den Bootmodus zu wechseln.
Die obere Schaltung setzt die hierfür notwendige logische Verknüfung zwischen DTR/RTS und EN/GPIO0 \ref{tab:cp2102n_dtr_rts} um.
Die beiden SS8050 sind npn-Bipolartransistoren. Diese Schaltung ist parallel geschaltet zu der Möglichkeit ESP\_EN und ESP\_IO0 über einen Taster auf GND zu ziehen.

\section{Layout}
Das Layout wurde mit dem Tool PCBNew aus KiCad erstellt. 
Die MainPCB Platine \ref{fig:kicad_mainpcb_layout} wurde als 4 Layer PCB umgesetzt (1. Schicht: Signal, 2.: 3.3V, 3.: 12V, 4.: GND) und LedPCB \ref{fig:kicad_ledpcb_layout} als 2 Layer (1.: 12V/Signal, 2.: GND).
Bei der Erstellung wurde versucht Angaben in den Datenblättern der Bauteile sowie "Good Practices" des Leiterplattenentwurf zu befolgen.
Im Folgenden wird somit nicht weiter darauf eingegangen.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Platinenentwurf/KiCad_MainPCB_Layout.png}
    \caption{KiCad MainPCB Layout}
    \label{fig:kicad_mainpcb_layout}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/Platinenentwurf/KiCad_LedPCB_Layout.png}
    \caption{KiCad LedPCB Layout}
    \label{fig:kicad_ledpcb_layout}
\end{figure}

\section{Designfehler}
Beim Schaltplan Design wurden leider 3 Fehler gemacht. Diese können allerdings ausgebessert werden oder beinträchtigen die Nutzung der Platine nur gering.
Der Dokumentation liegen einmal das fehlerhafte KiCad Projekt und eines mit ausgebesserten Fehlern bei.
\subsection*{3.3V Spannungswandler}
\begin{description}
    \item[Fehlerbeschreibung:] Der 3.3V Spannungwandler schaltet bei der Wandlung von 5V (USB, JTAG-/Programmierinterface) zu 3.3V ab. 
    Die Wandlung von 12V zu 3.3V funktioniert. 
    \item[Grund:] Über den Eingang EN des TPS54331 wird ein Unterspannungsschutz (UVLO) realisiert. Fällt die Spannung an EN unter $V_{EN} = 1.25V$ schaltet der Spannungswandler ab.
    Wie im Kapitel \ref{sub:tps54331} beschrieben lässt sich die minimal erlaubt Eingangsspannung über den Spannungsteiler $R_{en1}$ und $R_{en2}$ einstellen. 
    Diese ist für 5V falsch gewählt worden.
    \item[Fehlerbehebung:] Um den Unterspannungsschutz zu deaktivieren, können die Widerstände $R_{en1} = R1$ und $R_{en2} = R5 + R7$ entfernt werden.
\end{description}

\subsection*{CP2102N Stromversorgung}
\begin{description}
    \item[Fehlerbeschreibung:] Der Mikrocontroller startet nicht richtig, wenn die Platine nur über 12V verorgt wird und USB nicht verbunden ist.
    \item[Grund:] Da der CP2102N direkt über VBUS der USB Schnittstelle versorgt wird, ist der Chip nicht aktiv wenn nur die 12V Versorgung vorhanden ist.
    Die Ausgangssignale RTS und DTR sind somit "floatend"/undefiniert und können beim Einschalten der 12V einen Start in den Download Boot-Modus triggern.
    \item[Fehlerbehebung:] Damit die Ausgänge RTS und DTR immer auf definiertem Pegel sind, muss der CP2102N dauerhaft über die 3.3V versorgt sein. 
    Dazu muss REGIN mit 3.3V verbunden werden. Da der interne 5V zu 3.3V Regulator nicht mehr genutzt wird, kann das Label "CP2102N\_VDD" \ref{fig:cp2102nfehlerkorrektur} auch direkt mit 3.3V verbunden werden.
    Auf den bestehenden Platinen kann der Fehler behoben werden indem der CP210N Chip abgelötet wird und die Leiterspur zwischen VBUS und REGIN aufgetrennt wird. (Abbildung \ref{fig:cp2102nfehlerkorrekturlayout} grün)
    Anschließend muss REGIN mit VDD verbunden werden (Lötbrücke) und mithilfe von z.B. einem Kupferdraht mit 3.3V versorgt werden. (Abbildung \ref{fig:cp2102nfehlerkorrekturlayout} blau)
\end{description}

\begin{figure}[H]
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/KiCad_CP2102N_Fehlerkorrektur.png}
        \caption{CP2102N Fehlerkorrektur}
        \label{fig:cp2102nfehlerkorrektur}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/Platinenentwurf/KiCad_CP2102N_Fehlerkorrektur_Layout.png}
        \caption{CP2102N Korrektur Layout}
        \label{fig:cp2102nfehlerkorrekturlayout}      
    \end{minipage}
\end{figure}

\subsection*{USB-C Anschluss}
\begin{description}
    \item[Fehlerbeschreibung:] Die Signalübertragung über USB-C funktioniert nur in einer Steckrichtung. 
    \item[Grund:] Die Pins B6 und B7 wurden nicht mit D+/D- auf der Platine verbunden.
    \item[Fehlerbehebung:] Da die Lötstellen an der USB Buchse sehr klein sind, ist es nur schwer möglich eine Brücke zu löten.
\end{description}

\section{Verbesserungen} \label{ch:verbesserungen_hardware}
In zukünftigen Projektarbeiten wird die Platine wahrscheinlich weiter entwickelt.
Im Folgenden sollen deshalb mögliche Verbesserungsvorschläge aufgelistet werden.
\begin{itemize}
    \item Da das Ziel des Gesamtprojektes eine Roboterformation mit möglichst vielen einzelnen Robotern ist, muss zukünftig die Ladeinfrastruktur möglichst einfach gehalten werden.
    Aus diesem Grund ist es sinnvoll die Ladeelektronik für die LiIon Zellen direkt in die Platine zu integrieren. Über USB-C Power Delivery könnten die Roboter dann sehr einfach geladen werden.
    \item Momentan ist das Main\_PCB als 4 Layer Platine ausgelegt. Um die kosten der einzelnen Platine zu senken, sollte das Layout auf 2 Layer reduziert werden.
    \item Die Pinbelegung \ref{fig:esp32pinlayout} des ESP32 zeigt, dass es kaum mehr freie Pins am Mikrocontroller gibt. Die Regelung der Motoren belegt alleine neun dieser Pins.
    Diese könnte auf einen zweiten/sekundären Mikrocontroller ausgelagert werden. Somit würden wieder mehr Pins am ESP32 nutzbar sein. 
    Außerdem wird die ESP32 Software-Architektur vereinfacht und Rechenleistung für zukünftige Software Erweiterungen frei.
\end{itemize}
